////////////////////
// Lexical tokens //
////////////////////

COMMENT: ("'" | "REM ") /[^\n]*/
_NEWLINE: /\r?\n[\t \f]*/ | ":" // Logical line separator
eol: COMMENT | _NEWLINE

IDENTIFIER: /[a-zA-Z]([a-zA-Z0-9_])*/

/////////////////////////
// Module organisation //
/////////////////////////
?program: statement_block

statement_block: eol* (statement eol+)* [statement]
?statement: declarative
          | control
          | left_expression

// procedure_definition: subroutine-declaration
//                     | function-declaration


///////////////
// Procedure //
///////////////

subroutine_declaration: subroutine_header
subroutine_header: procedure_scope ["Static"] "Sub"

procedure_scope: "Global"
               | "Public"
               | "Private"
               | "Friend"


// subroutine-declaration = procedure-scope [initial-static]
// "sub" subroutine-name [procedure-parameters] [trailing-static] EOS
// [procedure-body EOS]
// [end-label] "end" "sub" procedure-tail
// function-declaration = procedure-scope [initial-static]
// "function" function-name [procedure-parameters] [function-type]
// [trailing-static] EOS
// [procedure-body EOS]
// [end-label] "end" "function" procedure-tail
// property-get-declaration = procedure-scope [initial-static]
// "Property" "Get"
// function-name [procedure-parameters] [function-type] [trailing-static] EOS
// [procedure-body EOS]
// [end-label] "end" "property" procedure-tail
// property-lhs-declaration = procedure-scope [initial-static]
// "Property" ("Let" / "Set")
// subroutine-name property-parameters [trailing-static] EOS
// [procedure-body EOS]
// [end-label] "end" "property" procedure-tail
// end-label = statement-label-definition
// procedure-tail = [WS] LINE-END / single-quote comment-body /
// ":" rem-statement


///////////////
// Statement //
///////////////

?declarative: variable_declaration
            | let_statement

variable_declaration: "Dim" simple_name_expression [AS [NEW] IDENTIFIER] [EQ expression]
let_statement: ["Let"] left_expression "=" expression


/////////////
// Control //
/////////////

?control: for_statement
        | if_statement
        | single_line_if_statement

for_statement: for_header eol statement_block for_footer
for_header: "For" left_expression "=" expression "To" expression ["Step" expression]
for_footer: "Next" [left_expression]

if_statement: if_header eol statement_block (elseif_block)* [else_block] if_footer
if_header: "If" expression "Then"
elseif_block: "ElseIf" expression "Then" eol statement_block
            | "ElseIf" expression "Then" statement
else_block: "Else" eol statement_block
if_footer: ("End If"| "EndIf")

single_line_if_statement: if_with_non_empty_then
                         | if_with_empty_then
if_with_non_empty_then: "If" expression "Then" statement [single_line_else_clause]
if_with_empty_then: "If" expression single_line_else_clause
single_line_else_clause: "Else" statement


////////////////
// Expression //
////////////////

expression: value_expression

// Operator expression
?value_expression: logical_imp
logical_imp: logical_imp IMP logical_eqv
            | logical_eqv
logical_eqv: logical_eqv EQV logical_xor
            | logical_xor
logical_xor: logical_xor XOR logical_or
            | logical_or
logical_or: logical_or OR logical_and
           | logical_and
logical_and: logical_and AND logical_not
            | logical_not
logical_not: NOT logical_not
            | relational_expresion
relational_expresion: relational_expresion RELATIONAL concatenation
                     | concatenation
concatenation: concatenation CONCATENATION additive_expression
              | additive_expression
additive_expression: additive_expression ADDITIVE modulus
                    | modulus
modulus: modulus MOD integer_division
        | integer_division
integer_division: integer_division INTEGER_DIVISION mutliplicative_expression
                 | mutliplicative_expression
mutliplicative_expression: mutliplicative_expression MULTIPLICATIVE unary_negation
                          | unary_negation
unary_negation: MINUS unary_negation
               | exponentiation
exponentiation: exponentiation EXPONENTIATION exponentiation
               | parenthesized_expression
parenthesized_expression: "(" expression ")"
                        | primary_expression
primary_expression: literal
                   | left_expression

// Literal
literal: INTEGER
       | BOOLEAN
       | STRING

INTEGER: SIGNED_INT
BOOLEAN: "True"
       | "False"
_STRING_CHARACTER: /[^"]/ | /""/
STRING: /"/ _STRING_CHARACTER* /"/

// Left expression
?left_expression: member_access_expression
               | index_expression
               | simple_name_expression
simple_name_expression: IDENTIFIER
member_access_expression: left_expression "." simple_name_expression
index_expression: left_expression "(" argument_list ")"

// Argument list
argument_list: [positional_argument_list| mixed_argument_list]
positional_argument_list: (optional_positional_argument ",")* argument_expression
mixed_argument_list: (optional_positional_argument ",")* named_argument_list
named_argument_list: named_argument ("," named_argument)*
optional_positional_argument: [argument_expression]
named_argument: IDENTIFIER ":=" argument_expression
argument_expression: [/ByVal/] expression
                   // | addressof-expression

// Operators
IMP: "Imp"
EQV: "Eqv"
XOR: "Xor"
OR: "Or"
AND: "And"
NOT: "Not"
RELATIONAL: "=" | "<>" | "<=" | ">=" | "<" | ">" | "Like" | "Is"
CONCATENATION: "&"
ADDITIVE: "+" | "-"
MOD: "Mod"
INTEGER_DIVISION: "\\"
MULTIPLICATIVE: "*" | "/"
MINUS: "-"
EXPONENTIATION: "^"


//////////////
// Keywords //
//////////////
AS: "As"
NEW: "New"
EQ: "="

// Utilities
list{element, separator}: [(element separator)* element]

%import common.WS
%import common.SIGNED_INT
%import common.LETTER
%ignore /[\t \f]+/  // Whitespaces
%ignore /_[\t \f]*\r?\n/   // Continued line